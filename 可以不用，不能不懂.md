# 🧠 排序算法笔记

——Created By Angela Teng

------

## 📌 1. 排序的基本概念

### ✅ 什么是排序？

将一组数据按照指定的**顺序**（如从小到大）进行重新排列的过程。

### ✅ 排序分类：

- **比较类排序**：通过比较元素大小确定顺序（如冒泡、选择、插入等）
- **非比较类排序**：不直接比较，而是通过“分布”统计处理（如计数、基数、桶排序）

### ✅ 常见指标：

| 指标       | 含义                                          |
| ---------- | --------------------------------------------- |
| 时间复杂度 | 排序过程中最多执行多少次操作（通常用 O 表示） |
| 空间复杂度 | 占用额外内存的多少                            |
| 稳定性     | 若两个值相等的元素，排序后相对位置是否改变    |

------

## 🔁 2. 冒泡排序（Bubble Sort）

### 💡 思想：

每一轮将相邻两个数进行比较，大的数“冒泡”到后面。

```cpp
void bubble_sort(int a[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        bool swapped = false; // 优化：记录是否有交换
        for (int j = 0; j < n - i - 1; ++j) {
            if (a[j] > a[j + 1]) {
                swap(a[j], a[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) break; // 如果一轮没有交换，说明已经有序
    }
}
```

### 📌 特点：

- 时间复杂度：O(n²)
- 空间复杂度：O(1)
- 稳定排序 ✅

------

## 🧲 3. 选择排序（Selection Sort）

### 💡 思想：

每轮从未排序区间选择最小值，放在当前最前面。

```cpp
void selection_sort(int a[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (a[j] < a[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            swap(a[i], a[minIndex]);
        }
    }
}
```

### 📌 特点：

- 时间复杂度：O(n²)
- 空间复杂度：O(1)
- 不稳定排序 ❌（相同元素可能换顺序）

------

## 🪜 4. 插入排序（Insertion Sort）

### 💡 思想：

将每个元素插入到前面已排好序的区间中，找到合适位置。

```cpp
void insertion_sort(int a[], int n) {
    for (int i = 1; i < n; ++i) {
        int key = a[i];
        int j = i - 1;
        // 向右移动比key大的元素
        while (j >= 0 && a[j] > key) {
            a[j + 1] = a[j];
            --j;
        }
        a[j + 1] = key; // 插入到正确位置
    }
}
```

### 📌 特点：

- 时间复杂度：O(n²)，但在接近有序时性能好
- 空间复杂度：O(1)
- 稳定排序 ✅

------

## 🧮 5. 计数排序（Counting Sort）

### 💡 思想：

统计每个数出现次数，按数量依次放回原数组。

> 适用于：非负整数，范围不大（如成绩、年龄等）

```cpp
void counting_sort(int a[], int n) {
    if (n == 0) return;

    // 找最大值
    int maxVal = a[0];
    for (int i = 1; i < n; ++i) {
        if (a[i] > maxVal)
            maxVal = a[i];
    }

    // 创建计数数组
    vector<int> count(maxVal + 1, 0);

    // 统计每个数字的出现次数
    for (int i = 0; i < n; ++i) {
        count[a[i]]++;
    }

    // 按照次数写回原数组
    int idx = 0;
    for (int num = 0; num <= maxVal; ++num) {
        while (count[num]--) {
            a[idx++] = num;
        }
    }
}
```

### 📌 特点：

- 时间复杂度：O(n + k)，k为元素范围
- 空间复杂度：O(k)
- 稳定排序 ✅（可通过额外记录顺序实现）

------

## 🧪 示例使用主函数（通用测试）

```cpp
#include <iostream>
#include <vector>
using namespace std;

void print(int a[], int n) {
    for (int i = 0; i < n; ++i) cout << a[i] << " ";
    cout << endl;
}

int main() {
    int a[] = {5, 3, 8, 6, 2, 7, 1, 4};
    int n = sizeof(a) / sizeof(a[0]);

    // bubble_sort(a, n);
    // selection_sort(a, n);
    // insertion_sort(a, n);
    counting_sort(a, n); // 你可以替换为任意算法函数

    print(a, n);
    return 0;
}
```

------

## 🏁 总结对比表

| 算法     | 时间复杂度 | 空间 | 稳定性 | 适用场景           |
| -------- | ---------- | ---- | ------ | ------------------ |
| 冒泡排序 | O(n²)      | O(1) | ✅      | 小规模数据、教学   |
| 选择排序 | O(n²)      | O(1) | ❌      | 简单但效率低       |
| 插入排序 | O(n²)/O(n) | O(1) | ✅      | 基本有序数据       |
| 计数排序 | O(n + k)   | O(k) | ✅      | 非负整数，分布集中 |

