# 动态规划解题的一般思路

#### 递归到动规的一般转化方法：

- 递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程。

#### 动规解题的一般思路：

1. :star: 将原问题分解为子问题

   - 把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决。（数字三角形例）
   - 子问题的解一旦求出就会被保存，所以每个子问题只需要求解一次。

2. :star:确定状态

   - 在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为`"状态"`。一个`"状态"`对应于一个或多个子问题，所谓某个`"状态"`下的`"值"`，就是这个`"状态"`所对应的子问题的解。
   - 所有`"状态"`的聚合，构成问题的`"状态空间"`。`"状态空间"`的大小，与用动态规划解决问题的时间复杂度直接相关。在数字三角形的例子里，一共有`N*(N+1)/2`个数字，所以这个问题的`"状态空间"`里一共就有`N*(N+1)/2`个状态。
   - `整个问题的时间复杂度是状态数目乘以计算每个状态所需时间`
   - 在数字三角形里每个`"状态"`只需要经过一次，且在每个状态上做计算所花的时间都是和N无关的常数。
   - **用动态规划解题，经常碰到的情况是，K个整型变量能构成一个状态（如数字三角形中的行号和列号这两个变量构成 "状态"**。如果这K个整型变量的取值范围分别是N1,N2,...Nk,那么，我们就可以用一个K维数组array [N1] [N2] ...[Nk]来存储各个`"状态"`的`"值"`。这个`"值"`未必就是一个整数或浮点数，可能是需要一个结构才能表示的，那么array就是可以是一个结构数组。一个`"状态"`下的`"值"`通常会是一个或多个子问题的解。

3. :star:确定一些初始状态（边界状态）的值

   以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。

4. :star: 确定状态转移方程

   定义出什么是`"状态"`，以及在该`"状态"`下的`"值"`后，就要找出不同的状态之间如何迁移——即如何从一个或多个`"值"`已知的`"状态"`。求出另一个`"状态"`的`"值"`（`人人为我`递推型）。状态的迁移可以用递推公式表示，此递推公式也可被称作`"状态转移方程"`。



数字三角形的状态转移方程：

​				D [r] [j]               r =N

MaxSum[r] [j]=   

​				Max(MaxSum[r+1] [j] ,MaxSum [r+1] [j+1]) + D[r] [j]  其他情况。
