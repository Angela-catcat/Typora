🌐 图的 DFS 与 BFS 竞赛笔记（C++ 模板）

📌 一、图的遍历简介

图的遍历是图论问题的基础操作，最常见的两种方式：

🔍 DFS（深度优先搜索）：优先探索分支路径

🔁 BFS（广度优先搜索）：优先探索同层节点

图的存储方式：

✅ 邻接表：适合稀疏图，竞赛最常用

✅ 邻接矩阵：适合稠密图，空间消耗大

🔍 二、DFS（深度优先搜索）

🧠 思路

每次访问一个新节点后，递归地访问它的邻居节点

类似"走迷宫"：一条路走到底再回溯

📦 模板代码（邻接表实现）

vector<int> G[N]; // 图的邻接表
bool vis[N];      // 是否访问过

void dfs(int u) {
    vis[u] = true;
    for (int v : G[u]) {
        if (!vis[v]) dfs(v);
    }
}

📚 应用场景

连通分量个数统计

图中路径搜索

拓扑排序（配合栈）

二分图染色、割点、强连通分量等

🔁 三、BFS（广度优先搜索）

🧠 思路

使用队列，每次从队头弹出一个节点，将其所有未访问的邻居入队

类似“层层推进”或“水波扩散”

📦 模板代码（邻接表实现）

queue<int> q;
void bfs(int start) {
    vis[start] = true;
    q.push(start);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : G[u]) {
            if (!vis[v]) {
                vis[v] = true;
                q.push(v);
            }
        }
    }
}

📚 应用场景

最短路径（无权图）

连通性判定

二分图判定

BFS 层序遍历类题

📘 四、常见题目推荐

题号

名称

类型

LeetCode 200

岛屿数量

DFS 图遍历

LeetCode 102

二叉树层序遍历

BFS

LeetCode 785

判断二分图

BFS 染色判定

AcWing 844

走迷宫

BFS 最短路径

AcWing 846

树的重心

DFS 树形递归

🧠 五、小技巧与注意点

BFS 用队列，DFS 用递归或栈

图可能不连通，记得枚举所有点进行 DFS/BFS

双向图记得建边两次：G[u].push_back(v) 与 G[v].push_back(u)

对于多组测试或需要重跑遍历的场景，记得 memset(vis, 0, sizeof vis);

❤️ 六、一句话总结

图的 DFS 适合递归搜索路径，BFS 适合最短路径与分层问题。两者模板必须熟练掌握，是图论题的通关秘籍！

